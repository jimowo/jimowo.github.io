import{_ as a,o as i,c as e,d as n}from"./app-ff5a96d8.js";const t="/assets/image-20220424153500110-84418c01.png",s="/assets/image-20220424161324998-db4091d9.png",p="/assets/image-20220424161516323-2a17d31c.png",r="/assets/image-20220424163837296-3dd1e01f.png",g="/assets/image-20220424164322950-de3ce94e.png",o="/assets/image-20220424164647288-67e576d9.png",l="/assets/image-20220424164952584-902cb2bb.png",d="/assets/image-20220530215006775-f19ca37c.png",c="/assets/image-20220530214309518-c9df680c.png",h="/assets/image-20220530214320409-46cb2d67.png",m="/assets/image-20220530214336582-f71ffbb7.png",u="/assets/image-20220530214406072-a4f20ee0.png",f="/assets/image-20220530214703809-9276b50b.png",_="/assets/image-20220530214737632-41a79c4f.png",b="/assets/image-20220530214816605-15065587.png",T="/assets/image-20220530214941450-d60c1584.png",x="/assets/image-20220530220550805-360851ff.png",P="/assets/image-20220530220602402-e1738315.png",k="/assets/image-20220530220734131-20441675.png",y="/assets/image-20220601083458070-22eb1a96.png",v="/assets/image-20220601083542688-6a26d44a.png",H="/assets/image-20220601090527855-0ccd3b3f.png",z="/assets/image-20220601151244206-8d2ae689.png",C="/assets/image-20220601151351231-1107da91.png",I="/assets/image-20220606104624138-3966f6ed.png",w="/assets/image-20220606104655840-bcd61591.png",R="/assets/image-20220606105057239-d280953d.png",S="/assets/image-20220606105104983-b24ad65a.png",E="/assets/image-20220606105213896-f2b95346.png",U="/assets/image-20220606105546497-1e01f672.png",N="/assets/image-20220606105657052-89320a84.png",O="/assets/image-20220606105946593-2d35aa0c.png",X="/assets/image-20220606153105058-069db9af.png",G="/assets/image-20220606153504993-43cd7c9c.png",L="/assets/image-20220607101723849-71c51b89.png",M="/assets/image-20220607102537456-b52127d2.png",W="/assets/image-20220607150540596-dbe165f7.png",A="/assets/image-20220607153136712-313e5314.png",D="/assets/image-20220607154559474-bcd70d72.png",q="/assets/image-20220607161416653-3cdaf675.png",F="/assets/image-20220607162623180-bbd3f411.png",j="/assets/image-20220607162710737-ee5bda84.png",B="/assets/image-20220613160632816-7430d0b2.png",K="/assets/image-20220613161119615-50b13c19.png",J="/assets/image-20220613161217832-442c6af4.png",V="/assets/image-20220613161446751-06160a50.png",Q="/assets/image-20220613161503789-832c1139.png",Y="/assets/image-20220613161528167-7477f53a.png",Z="/assets/image-20220613162803226-2788f519.png",$="/assets/image-20220613162851171-f2d83fc4.png",aa="/assets/image-20220613162920590-ec4e24c1.png",ia="/assets/image-20220613163248334-7df96107.png",ea="/assets/image-20220613163630941-2f85ae6b.png",na="/assets/image-20220613163715233-2b0838b1.png",ta="/assets/image-20220613163753679-fd1cef28.png",sa="/assets/image-20220613163853802-69637dd6.png",pa={},ra=n('<h1 id="图解http笔记" tabindex="-1"><a class="header-anchor" href="#图解http笔记" aria-hidden="true">#</a> 图解HTTP笔记</h1><h2 id="第一章-了解web及网络基础" tabindex="-1"><a class="header-anchor" href="#第一章-了解web及网络基础" aria-hidden="true">#</a> 第一章 了解Web及网络基础</h2><h3 id="_1-2-http的诞生" tabindex="-1"><a class="header-anchor" href="#_1-2-http的诞生" aria-hidden="true">#</a> 1.2 HTTP的诞生</h3><h4 id="_3项www构建技术" tabindex="-1"><a class="header-anchor" href="#_3项www构建技术" aria-hidden="true">#</a> 3项WWW构建技术</h4><ul><li>SGML（标准通用标记语言）</li><li>HTML（超文本标记语言）：作为页面的文本标记语言</li><li>HTTP：文档传递协议</li><li>URL（统一资源定位符）：指定文档所在地址</li></ul><h3 id="_1-3-网络基础-tcp-ip" tabindex="-1"><a class="header-anchor" href="#_1-3-网络基础-tcp-ip" aria-hidden="true">#</a> 1.3 网络基础 TCP/IP</h3><p>通常使用的网络是在TCP/IP协议族的基础上运作的，HTTP属于它的子集</p><h4 id="tcp-ip协议族" tabindex="-1"><a class="header-anchor" href="#tcp-ip协议族" aria-hidden="true">#</a> TCP/IP协议族</h4><figure><img src="'+t+'" alt="image-20220424153500110" tabindex="0" loading="lazy"><figcaption>image-20220424153500110</figcaption></figure><h4 id="tcp-ip的分层管理" tabindex="-1"><a class="header-anchor" href="#tcp-ip的分层管理" aria-hidden="true">#</a> TCP/IP的分层管理</h4><p>TCP/IP分为4层：应用层、传输层、网络层、数据链路层</p><ul><li>应用层决定了向用户提供应用服务时通信的<strong>活动</strong>（HTTP、FTP）</li><li>传输层提供处于网络连接中的两台计算机的<strong>数据传输</strong>（TCP、UDP）</li><li>网络层用来处理网络上流动的<strong>数据包</strong>（IP）</li><li>链路层用来处理连接网络的硬件部分（设备驱动、网络适配器）</li></ul><h4 id="tcp-ip通信传输" tabindex="-1"><a class="header-anchor" href="#tcp-ip通信传输" aria-hidden="true">#</a> TCP/IP通信传输</h4><figure><img src="'+s+'" alt="image-20220424161324998" tabindex="0" loading="lazy"><figcaption>image-20220424161324998</figcaption></figure><p>数据每通过一层都会加上该层的首部</p><figure><img src="'+p+'" alt="image-20220424161516323" tabindex="0" loading="lazy"><figcaption>image-20220424161516323</figcaption></figure><h3 id="_1-4-与http关系密切的协议" tabindex="-1"><a class="header-anchor" href="#_1-4-与http关系密切的协议" aria-hidden="true">#</a> 1.4 与HTTP关系密切的协议</h3><h4 id="负责传输的ip协议" tabindex="-1"><a class="header-anchor" href="#负责传输的ip协议" aria-hidden="true">#</a> 负责传输的IP协议</h4><p>IP地址指明了节点被分配到的地址</p><p>MAC地址是网卡所属的固定地址</p><p>中转时使用ARP协议 根据MAC地址发送</p><h4 id="确保可靠性的tcp协议" tabindex="-1"><a class="header-anchor" href="#确保可靠性的tcp协议" aria-hidden="true">#</a> 确保可靠性的TCP协议</h4><ul><li><p>字节流传输：把大块数据分割成报文段为单位的数据包进行管理</p></li><li><p>确保数据能准确发送：发送后会进行三次握手，确保数据发送成功</p><figure><img src="'+r+'" alt="image-20220424163837296" tabindex="0" loading="lazy"><figcaption>image-20220424163837296</figcaption></figure></li></ul><h3 id="_1-5-负责域名解析的dns服务" tabindex="-1"><a class="header-anchor" href="#_1-5-负责域名解析的dns服务" aria-hidden="true">#</a> 1.5 负责域名解析的DNS服务</h3><p>DNS是HTTP一样位于应用层的协议，提供域名到IP地址之间的解析服务，或逆向从IP地址反查域名的服务</p><p>xxx.com就是域名，DNS把它转成IP地址</p><p>​ <img src="'+g+'" alt="image-20220424164322950" loading="lazy"></p><h3 id="_1-6-http通信的流程" tabindex="-1"><a class="header-anchor" href="#_1-6-http通信的流程" aria-hidden="true">#</a> 1.6 HTTP通信的流程</h3><figure><img src="'+o+'" alt="image-20220424164647288" tabindex="0" loading="lazy"><figcaption>image-20220424164647288</figcaption></figure><h3 id="_1-7-uri和url" tabindex="-1"><a class="header-anchor" href="#_1-7-uri和url" aria-hidden="true">#</a> 1.7 URI和URL</h3><h4 id="统一资源标识符-uri" tabindex="-1"><a class="header-anchor" href="#统一资源标识符-uri" aria-hidden="true">#</a> 统一资源标识符（URI）</h4><ul><li><p>URI的格式</p><figure><img src="'+l+`" alt="image-20220424164952584" tabindex="0" loading="lazy"><figcaption>image-20220424164952584</figcaption></figure><p>登录信息：指定用户名和密码作为从服务器获得资源时的登录信息（可选）</p><p>服务器地址：可以是xxx.com的DNS可解析域名也可以是IP地址</p><p>端口号：指定服务器连接的网络端口号（可选）</p><p>带层次的文件路径：指定服务器上的文件路径来定位资源</p><p>查询字符串：针对指定的资源可以使用查询字符串传入任意参数（可选）</p><p>片段标识符：标记出已经获得资源中的子资源（比如文档的某个位置）（可选）</p></li></ul><h2 id="第二章-简单的http协议" tabindex="-1"><a class="header-anchor" href="#第二章-简单的http协议" aria-hidden="true">#</a> 第二章 简单的HTTP协议</h2><h3 id="_2-1-http用于客户端和服务器端之间的通信" tabindex="-1"><a class="header-anchor" href="#_2-1-http用于客户端和服务器端之间的通信" aria-hidden="true">#</a> 2.1 HTTP用于客户端和服务器端之间的通信</h3><p>客户端发送请求，服务器应答，通过HTTP协议能够明确区分两端</p><h3 id="_2-2-通过请求和响应的交换达成通信" tabindex="-1"><a class="header-anchor" href="#_2-2-通过请求和响应的交换达成通信" aria-hidden="true">#</a> 2.2 通过请求和响应的交换达成通信</h3><p>下面是一个<strong>客户端的请求报文</strong></p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/index.htm</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">hackr.jp</span></span>
<span class="token header"><span class="token header-name keyword">Connection</span><span class="token punctuation">:</span> <span class="token header-value">keep-alive</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">application/x-www-form-urlencoded</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">16</span></span>
name=ueno&amp;age=37
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>GET 表示方法，/index.htm 指明了访问的资源对象，最后的HTTP/1.1 表示HTTP协议的版本号</p><p>中间的是请求首部字段、</p><p>最下面是内容实体</p><p>下面是一个<strong>服务器的响应报文</strong></p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token response-status"><span class="token http-version property">HTTP/1.1</span> <span class="token status-code number">200</span> <span class="token reason-phrase string">OK</span></span>
<span class="token header"><span class="token header-name keyword">Date</span><span class="token punctuation">:</span> <span class="token header-value">Tue, 10 Jul 2012 06:50:15 GMT</span></span>
<span class="token header"><span class="token header-name keyword">Content-Length</span><span class="token punctuation">:</span> <span class="token header-value">362</span></span>
<span class="token header"><span class="token header-name keyword">Content-Type</span><span class="token punctuation">:</span> <span class="token header-value">text/html</span></span>
<span class="token text-html">
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
...
</span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HTTP/1.1 表示HTTP协议的版本号，200 表示请求处理结果的状态码，OK 是原因短语</p><p>中间是首部字段，显示时间和一些内容属性</p><p>空行之后是内容的实体</p><h3 id="_2-3-http不保存之前状态" tabindex="-1"><a class="header-anchor" href="#_2-3-http不保存之前状态" aria-hidden="true">#</a> 2.3 HTTP不保存之前状态</h3><p>HTTP协议自身不对请求和响应做持久化处理，为了保存状态引入了<strong>Cookie技术</strong></p><h3 id="_2-4-uri定位资源" tabindex="-1"><a class="header-anchor" href="#_2-4-uri定位资源" aria-hidden="true">#</a> 2.4 URI定位资源</h3><p>多种URI请求方式</p><ul><li><p>完整URI</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">http://hackr.jp/index.htm</span> <span class="token http-version property">HTTP/1.1</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>再首部字段Host中写明域名或IP地址</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code><span class="token request-line"><span class="token method property">GET</span> <span class="token request-target url">/index.htm</span> <span class="token http-version property">HTTP/1.1</span></span>
<span class="token header"><span class="token header-name keyword">Host</span><span class="token punctuation">:</span> <span class="token header-value">hackr.jp</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>对服务器自身发送请求</p><div class="language-http line-numbers-mode" data-ext="http"><pre class="language-http"><code>OPTIONS * HTTP/1.1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面表示查询HTTP服务器端支持的HTTP方法种类</p><h3 id="_2-5-告知服务器意图的-http方法" tabindex="-1"><a class="header-anchor" href="#_2-5-告知服务器意图的-http方法" aria-hidden="true">#</a> 2.5 告知服务器意图的 HTTP方法</h3><figure><img src="`+d+'" alt="image-20220530215006775" tabindex="0" loading="lazy"><figcaption>image-20220530215006775</figcaption></figure><p>GET：获取资源</p><figure><img src="'+c+'" alt="image-20220530214309518" tabindex="0" loading="lazy"><figcaption>image-20220530214309518</figcaption></figure><p>POST：传输实体</p><figure><img src="'+h+'" alt="image-20220530214320409" tabindex="0" loading="lazy"><figcaption>image-20220530214320409</figcaption></figure><figure><img src="'+m+'" alt="image-20220530214336582" tabindex="0" loading="lazy"><figcaption>image-20220530214336582</figcaption></figure><p>PUT：传输文件</p><figure><img src="'+u+'" alt="image-20220530214406072" tabindex="0" loading="lazy"><figcaption>image-20220530214406072</figcaption></figure><p>HEAD：获取报文首部</p><p>HEAD方法和GET方法的区别在于不返回报文的主体部分，用于确认URI的有效性及资源的更新日期时间</p><p>DELETE：删除文件</p><img src="'+f+'" alt="image-20220530214703809"><p>OPTIONS：询问支持</p><figure><img src="'+_+'" alt="image-20220530214737632" tabindex="0" loading="lazy"><figcaption>image-20220530214737632</figcaption></figure><p>TRACE：追踪路径</p><figure><img src="'+b+'" alt="image-20220530214816605" tabindex="0" loading="lazy"><figcaption>image-20220530214816605</figcaption></figure><p>CONNECT：要求用隧道协议链接代理</p><p>通过代理服务器把通信内容加密后经网络隧道传输</p><figure><img src="'+T+'" alt="image-20220530214941450" tabindex="0" loading="lazy"><figcaption>image-20220530214941450</figcaption></figure><h3 id="_2-7-持久连接节省通信量" tabindex="-1"><a class="header-anchor" href="#_2-7-持久连接节省通信量" aria-hidden="true">#</a> 2.7 持久连接节省通信量</h3><p>旧版的HTTP协议每次发送HTTP请求时都要断开TCP连接</p><p>新版只要任意一端没有明确提出断开连接，则保持TCP连接状态</p><p>管线化使得不用等待前一个请求的响应即可发送下一个请求，并行发送</p><h3 id="_2-8-使用cookie的状态管理" tabindex="-1"><a class="header-anchor" href="#_2-8-使用cookie的状态管理" aria-hidden="true">#</a> 2.8 使用Cookie的状态管理</h3><p>Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端状态</p><p>在报文内加入一个叫Set-Cookie的首部字段信息，通知客户端保存Cookie，下次客户端再发送请求时会自动在请求报文中加入Cookie值后发送</p><p>服务器发现客户端发送的Cookie后会对比服务器上的记录，得到之前的状态信息</p><figure><img src="'+x+'" alt="image-20220530220550805" tabindex="0" loading="lazy"><figcaption>image-20220530220550805</figcaption></figure><figure><img src="'+P+'" alt="image-20220530220602402" tabindex="0" loading="lazy"><figcaption>image-20220530220602402</figcaption></figure><figure><img src="'+k+'" alt="image-20220530220734131" tabindex="0" loading="lazy"><figcaption>image-20220530220734131</figcaption></figure><h2 id="第三章-http报文内的http信息" tabindex="-1"><a class="header-anchor" href="#第三章-http报文内的http信息" aria-hidden="true">#</a> 第三章 HTTP报文内的HTTP信息</h2><h3 id="_3-1-http报文" tabindex="-1"><a class="header-anchor" href="#_3-1-http报文" aria-hidden="true">#</a> 3.1 HTTP报文</h3><p>HTTP报文结构如下</p><figure><img src="'+y+'" alt="image-20220601083458070" tabindex="0" loading="lazy"><figcaption>image-20220601083458070</figcaption></figure><p>请求报文和响应报文的结构如下</p><figure><img src="'+v+'" alt="image-20220601083542688" tabindex="0" loading="lazy"><figcaption>image-20220601083542688</figcaption></figure><h3 id="_3-3-编码-提升传输速率" tabindex="-1"><a class="header-anchor" href="#_3-3-编码-提升传输速率" aria-hidden="true">#</a> 3.3 编码 提升传输速率</h3><ul><li><p><strong>介绍</strong></p><p>HTTP在传输时可以按照原数据直接传输，也可以通过编码来提升传输速率</p><p>一个报文分为报文首部和报文主体，报文主体是用来传输主体（entity）</p><p>HTTP的<strong>内容编码</strong>是用在实体上的编码格式</p><p>常见的编码格式有</p><ol><li>gzip（GNU zip）</li><li>compress（UNIX 系统的标准压缩）</li><li>deflate（zlib）</li><li>identity（不进行编码）</li></ol></li><li><p><strong>分割发送的分块传输编码</strong></p><p>在HTTP通信中，请求的编码实体资源在尚未传输完成时，页面是无法显示的，所以在传输大容量数据时，一般将编码实体资源进行分块，这样传输过程中可以让浏览器逐步显示页面，这种技术叫<strong>分块传输编码</strong>（Chunked Transfer Coding）</p><figure><img src="'+H+'" alt="image-20220601090527855" tabindex="0" loading="lazy"><figcaption>image-20220601090527855</figcaption></figure><p>其中每一块都会由一个16进制数来标记块的大小，最后一块会使用“0（CR+LF）”来标记</p></li></ul><h3 id="_3-4-发送多种数据的-多部分对象集合" tabindex="-1"><a class="header-anchor" href="#_3-4-发送多种数据的-多部分对象集合" aria-hidden="true">#</a> 3.4 发送多种数据的 多部分对象集合</h3><p>HTTP 协议采用了类似<strong>MIME机制</strong>（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）发送的一份报文可以含有多类型实体</p><p>多部分对象集合包含</p><ol><li>form-data：上传Web表单时使用</li><li>byteranges：</li></ol><p>在HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type</p><h3 id="_3-5-获取部分内容的-范围请求" tabindex="-1"><a class="header-anchor" href="#_3-5-获取部分内容的-范围请求" aria-hidden="true">#</a> 3.5 获取部分内容的 范围请求</h3><p>为了解决下载过程中的网络中断问题，需要一种可恢复的机制，即从中断处恢复下载</p><p>从中断处继续下载，就要像服务器请求从中断处开始的范围内容，即<strong>范围请求</strong>（Range Request），对一份10 000字节大小的资源可以只请求 5001~10 000字节内的资源</p><figure><img src="'+z+'" alt="image-20220601151244206" tabindex="0" loading="lazy"><figcaption>image-20220601151244206</figcaption></figure><p>byte范围的指定形式如下</p><figure><img src="'+C+'" alt="image-20220601151351231" tabindex="0" loading="lazy"><figcaption>image-20220601151351231</figcaption></figure><p>针对范围请求，响应会返回状态码 206 Partial Content，如果是多重范围请求则会在 Content-Type 标明 multipart/byteranges</p><h3 id="_3-6-内容协商-返回最合适的内容" tabindex="-1"><a class="header-anchor" href="#_3-6-内容协商-返回最合适的内容" aria-hidden="true">#</a> 3.6 内容协商 返回最合适的内容</h3><p>同一个网站可能存在多份相同内容的页面，比如可能存在一份英文版和中文版的页面，根据浏览器的默认语言来切换，这就是<strong>内容协商机制</strong></p><p>包含在请求报文中的某些<strong>首部字段</strong>就是<strong>判断基准</strong></p><ul><li>Accept</li><li>Accept-Charset</li><li>Accept-Encoding</li><li>Accept-Language</li><li>Content-Language</li></ul><p>内容协商技术有以下3种类型</p><ul><li><p><strong>服务器驱动协商</strong></p><p>由服务器端进行协商，以请求报文的首部字段为参考，在服务器端处理</p></li><li><p><strong>客户端驱动协商</strong></p><p>用户从浏览器显示的可选项列表中手动选择，还可以利用JS脚本在Web页面上自动进行选择。比如按OS类型自动切换成PC版或手机版页面</p></li><li><p><strong>透明协商</strong></p><p>服务器驱动协商和客户端驱动协商的结合体，服务器端和客户端各自进行内容协商</p></li></ul><h2 id="第四章-返回结果的http状态码" tabindex="-1"><a class="header-anchor" href="#第四章-返回结果的http状态码" aria-hidden="true">#</a> 第四章 返回结果的HTTP状态码</h2><h3 id="_4-1-状态码-告知从服务器端返回得请求结果" tabindex="-1"><a class="header-anchor" href="#_4-1-状态码-告知从服务器端返回得请求结果" aria-hidden="true">#</a> 4.1 状态码 告知从服务器端返回得请求结果</h3><p>状态码是服务器端响应时得请求结果</p><figure><img src="'+I+'" alt="image-20220606104624138" tabindex="0" loading="lazy"><figcaption>image-20220606104624138</figcaption></figure><p>状态码类别</p><figure><img src="'+w+'" alt="image-20220606104655840" tabindex="0" loading="lazy"><figcaption>image-20220606104655840</figcaption></figure><p>遵守以上定义，可以<strong>自定义状态码</strong></p><h3 id="_4-2-2xx-成功状态码" tabindex="-1"><a class="header-anchor" href="#_4-2-2xx-成功状态码" aria-hidden="true">#</a> 4.2 2XX 成功状态码</h3><ul><li><p>200 OK：表示客户端发来得请求在服务器端被正常处理了<img src="'+R+'" alt="image-20220606105057239" loading="lazy"></p></li><li><p>204 No Content：表示请求已正确处理，但响应报文中不包含实体得主体部分<br><img src="'+S+'" alt="image-20220606105104983" loading="lazy"></p></li><li><p>206 Partial Content：表示对范围请求的正确处理</p><figure><img src="'+E+'" alt="image-20220606105213896" tabindex="0" loading="lazy"><figcaption>image-20220606105213896</figcaption></figure></li></ul><h3 id="_4-3-3xx-重定向状态码" tabindex="-1"><a class="header-anchor" href="#_4-3-3xx-重定向状态码" aria-hidden="true">#</a> 4.3 3XX 重定向状态码</h3><ul><li><p>301 Moved Permanently：永久重定向，表示请求的资源已被分配了新的URI</p><figure><img src="'+U+'" alt="image-20220606105546497" tabindex="0" loading="lazy"><figcaption>image-20220606105546497</figcaption></figure></li><li><p>302 Found：临时性重定向，表示请求的资源已被分配了新的URI，希望用户能够使用新的URI访问</p><figure><img src="'+N+'" alt="image-20220606105657052" tabindex="0" loading="lazy"><figcaption>image-20220606105657052</figcaption></figure></li><li><p>303 See Other：表示由于请求的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源，与302的区别在于指明采用 GET 方法</p><figure><img src="'+O+'" alt="image-20220606105946593" tabindex="0" loading="lazy"><figcaption>image-20220606105946593</figcaption></figure></li><li><p>304 Not Modified：表示当客户端发送附带条件的请求时，服务器允许访问资源，但未满足条件</p><figure><img src="'+X+'" alt="image-20220606153105058" tabindex="0" loading="lazy"><figcaption>image-20220606153105058</figcaption></figure></li><li><p>307 Temporary Redirect：临时重定向</p></li></ul><h3 id="_4-4-4xx-客户端错误状态码" tabindex="-1"><a class="header-anchor" href="#_4-4-4xx-客户端错误状态码" aria-hidden="true">#</a> 4.4 4XX 客户端错误状态码</h3><ul><li><p>400 Bad Request：报文中存在语法错误</p></li><li><p>401 Unauthorized：请求 HTTP 验证</p><figure><img src="'+G+'" alt="image-20220606153504993" tabindex="0" loading="lazy"><figcaption>image-20220606153504993</figcaption></figure></li><li><p>403 Forbidden：请求资源的访问被服务器拒绝</p></li><li><p>404 Not Found：服务器上没有请求的资源</p></li></ul><h3 id="_4-5-5xx-服务器错误状态码" tabindex="-1"><a class="header-anchor" href="#_4-5-5xx-服务器错误状态码" aria-hidden="true">#</a> 4.5 5XX 服务器错误状态码</h3><ul><li>500 Internet Server Error：服务器端在执行请求时发生错误</li><li>503 Service Unavailable：服务器超载或正在停机维护</li></ul><h2 id="第五章-与-http-协作的-web-服务器" tabindex="-1"><a class="header-anchor" href="#第五章-与-http-协作的-web-服务器" aria-hidden="true">#</a> 第五章 与 HTTP 协作的 Web 服务器</h2><p>一台 Web 服务器可搭建多个独立域名的 Web 网站，也可做为中转服务器提升传输效率</p><h3 id="_5-1-用单台虚拟主机实现多个域名" tabindex="-1"><a class="header-anchor" href="#_5-1-用单台虚拟主机实现多个域名" aria-hidden="true">#</a> 5.1 用单台虚拟主机实现多个域名</h3><p>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点，只要使用<strong>虚拟主机</strong>的功能</p><figure><img src="'+L+'" alt="image-20220607101723849" tabindex="0" loading="lazy"><figcaption>image-20220607101723849</figcaption></figure><p>如果一台服务器内托管了多个域名，当收到请求时就需要弄清究竟要访问那个域名，发送 HTTP 请求时，必须在 <strong>Host 首部</strong>内完整指定主机名或域名的 URI</p><figure><img src="'+M+'" alt="image-20220607102537456" tabindex="0" loading="lazy"><figcaption>image-20220607102537456</figcaption></figure><h3 id="_5-2-通信数据转发程序-代理、网关、隧道" tabindex="-1"><a class="header-anchor" href="#_5-2-通信数据转发程序-代理、网关、隧道" aria-hidden="true">#</a> 5.2 通信数据转发程序：代理、网关、隧道</h3><p>这些应用程序可以将请求<strong>转发</strong>给通信线路上的<strong>下一站服务器</strong>，并且能接收从那台服务器发送的响应再转发给客户端</p><ul><li><p><strong>代理</strong></p><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端之间的“中间人”角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端</p><figure><img src="'+W+'" alt="image-20220607150540596" tabindex="0" loading="lazy"><figcaption>image-20220607150540596</figcaption></figure><p>在 HTTP 通信过程中，可级联多台代理服务器，转发时需要附加 Via 首部字段以标记出经过的代理服务器信息</p><ol><li>缓存代理：将资源副本缓存在代理服务器上</li><li>透明代理：不对报文做任何处理加工</li></ol></li><li><p><strong>网关</strong></p><p>网关是转发其他服务器通信数据的服务器，接收到客户端的请求时，它就像自己拥有资源的源服务器一样对请求进行处理</p><p>网关的机制和代理相似，而网关能使通信线路上的服务器提供非 HTTP 服务</p><figure><img src="'+A+'" alt="image-20220607153136712" tabindex="0" loading="lazy"><figcaption>image-20220607153136712</figcaption></figure><p>利用网关可以提高通信的安全性</p></li><li><p><strong>隧道</strong></p><p>隧道是在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接的应用程序</p><p>隧道的目的是确保客户端与服务器，使用 SSL 等加密手段进行通信，隧道本身不会去解析 HTTP 请求</p><figure><img src="'+D+'" alt="image-20220607154559474" tabindex="0" loading="lazy"><figcaption>image-20220607154559474</figcaption></figure></li></ul><h3 id="_5-3-保存资源的缓存" tabindex="-1"><a class="header-anchor" href="#_5-3-保存资源的缓存" aria-hidden="true">#</a> 5.3 保存资源的缓存</h3><p>缓存指代理服务器保存的资源副本</p><figure><img src="'+q+'" alt="image-20220607161416653" tabindex="0" loading="lazy"><figcaption>image-20220607161416653</figcaption></figure><ul><li><p>缓存的有效期限</p><figure><img src="'+F+'" alt="image-20220607162623180" tabindex="0" loading="lazy"><figcaption>image-20220607162623180</figcaption></figure></li><li><p>客户端的缓存</p><p>客户端也可以有缓存，称为临时网络文件，一样会过期</p><figure><img src="'+j+'" alt="image-20220607162710737" tabindex="0" loading="lazy"><figcaption>image-20220607162710737</figcaption></figure></li></ul><h2 id="第六章-http-首部" tabindex="-1"><a class="header-anchor" href="#第六章-http-首部" aria-hidden="true">#</a> 第六章 HTTP 首部</h2><h3 id="_6-1-http-报文首部" tabindex="-1"><a class="header-anchor" href="#_6-1-http-报文首部" aria-hidden="true">#</a> 6.1 HTTP 报文首部</h3><p>HTTP 报文得结构为</p><figure><img src="'+B+'" alt="image-20220613160632816" tabindex="0" loading="lazy"><figcaption>image-20220613160632816</figcaption></figure><p>报文首部又分为</p><figure><img src="'+K+'" alt="image-20220613161119615" tabindex="0" loading="lazy"><figcaption>image-20220613161119615</figcaption></figure><h3 id="_6-2-http-首部字段" tabindex="-1"><a class="header-anchor" href="#_6-2-http-首部字段" aria-hidden="true">#</a> 6.2 HTTP 首部字段</h3><p>使用首部字段是为了给浏览器和服务器提供报文主体大小，所使用得语言、认证信息等内容。</p><ul><li><p>HTTP 首部字段格式</p><figure><img src="'+J+'" alt="image-20220613161217832" tabindex="0" loading="lazy"><figcaption>image-20220613161217832</figcaption></figure></li><li><p>4 种 HTTP 首部字段类型</p><p>首部字段根据实际用途被分为4类</p><ul><li>通用首部字段</li><li>请求首部字段</li><li>响应首部字段</li><li>实体首部字段</li></ul></li><li><p>首部字段一览</p><img src="'+V+'" alt="image-20220613161446751" style="zoom:80%;"><img src="'+Q+'" alt="image-20220613161503789" style="zoom:80%;"><img src="'+Y+'" alt="image-20220613161528167" style="zoom:80%;"></li></ul><h3 id="_6-7-为-cookie-服务的首部字段" tabindex="-1"><a class="header-anchor" href="#_6-7-为-cookie-服务的首部字段" aria-hidden="true">#</a> 6.7 为 Cookie 服务的首部字段</h3><img src="'+Z+'" alt="image-20220613162803226" style="zoom:80%;"><ul><li><p>Set-Cookie</p><p>格式为：<img src="'+$+'" alt="image-20220613162851171" loading="lazy"></p><p>各字段值：</p><figure><img src="'+aa+'" alt="image-20220613162920590" tabindex="0" loading="lazy"><figcaption>image-20220613162920590</figcaption></figure></li><li><p>Cookie</p><p>首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到 Cookie。</p><figure><img src="'+ia+'" alt="image-20220613163248334" tabindex="0" loading="lazy"><figcaption>image-20220613163248334</figcaption></figure></li></ul><h3 id="_6-8-其他首部字段" tabindex="-1"><a class="header-anchor" href="#_6-8-其他首部字段" aria-hidden="true">#</a> 6.8 其他首部字段</h3><ul><li><p>X-Frame-Options</p><figure><img src="'+ea+'" alt="image-20220613163630941" tabindex="0" loading="lazy"><figcaption>image-20220613163630941</figcaption></figure></li><li><p>X-XSS-Protection</p><figure><img src="'+na+'" alt="image-20220613163715233" tabindex="0" loading="lazy"><figcaption>image-20220613163715233</figcaption></figure></li><li><p>DNT</p><figure><img src="'+ta+'" alt="image-20220613163753679" tabindex="0" loading="lazy"><figcaption>image-20220613163753679</figcaption></figure></li><li><p>P3P</p><figure><img src="'+sa+'" alt="image-20220613163853802" tabindex="0" loading="lazy"><figcaption>image-20220613163853802</figcaption></figure></li></ul><h2 id="第七章-确保-web-安全的-https" tabindex="-1"><a class="header-anchor" href="#第七章-确保-web-安全的-https" aria-hidden="true">#</a> 第七章 确保 Web 安全的 HTTPS</h2>',155),ga=[ra];function oa(la,da){return i(),e("div",null,ga)}const ha=a(pa,[["render",oa],["__file","图解HTTP笔记.html.vue"]]);export{ha as default};
